# **BookStore**

Проект представляет собой полнофункциональное веб-приложение для книжного интернет-магазина, ключевой особенностью которого является интегрированный ИИ-ассистент для семантического поиска и подбора книг.

Цель проекта — предложить решение классической проблемы пользователей: поиск книг по нечётким, описательным запросам. В дополнение к традиционному поиску по ключевым словам, интернет-магазин также предлагает интуитивный диалог с ИИ-ассистентом, который понимает смысл и контекст запроса, помогая читателям находить идеальные книги, даже не зная их точного названия или автора.

#### Основные возможности
* **Интеллектуальный поиск с ИИ-ассистентом:**
  * **Семантический поиск:** Возможность искать книги по описанию сюжета, настроению, атмосфере или просто "похожие на..." (реализовано с помощью паттерна RAG - Retrieval-Augmented Generation).
  * **Диалоговый интерфейс:** Общение с чат-ботом, который может отвечать на структурированные вопросы о каталоге (например, "какая книга самая популярная?" или "покажи отзывы") благодаря использованию инструментов (Tools).

* **Классический поиск:**
  * Быстрый полнотекстовый поиск по каталогу (название, автор) с использованием Elasticsearch для обеспечения высокой релевантности и скорости ответа.
* **Управление каталогом:**
  * Просмотр, добавление и редактирование книг в административной панели.
  * **Автоматический импорт данных:** Интеграция с **Google Books API** для быстрого добавления новых книг в каталог по названию или ISBN.


* **Пользовательский функционал:**
  * Просмотр детальной информации о каждой книге.
  * Оформление заказа.


* **Функционал менеджера:**
  * Управление заказами.
  * Просмотр статистики по продажам.

#### Сервер: https://github.com/Helltu/BookStoreServer
#### Клиент: https://github.com/Helltu/BookStoreClient

---

## **Содержание**

1. [Архитектура](#архитектура)
    1. [C4-модель](#c4-модель)
    2. [Схема данных](#схема-данных)
2. [Функциональные возможности](#функциональные-возможности)
    1. [Диаграмма вариантов использования](#диаграмма-вариантов-использования)
    2. [User-flow диаграммы](#user-flow-диаграммы)
3. [Детали реализации](#детали-реализации)
    1. [UML-диаграммы](#uml-диаграммы)
    2. [Спецификация API](#спецификация-API)
    3. [Безопасность](#безопасность)
    4. [Оценка качества кода](#оценка-качества-кода)
4. [Тестирование](#тестирование)
    1. [Unit-тесты](#unit-тесты)
    2. [Интеграционные тесты](#интеграционные-тесты)
5. [Установка и запуск](#установка-и-запуск)
    1. [Манифесты для сборки docker образов](#манифесты-для-сборки-docker-образов)
    2. [Манифесты для развертывания k8s кластера](#манифесты-для-развертывания-k8s-кластера)
6. [Лицензия](#лицензия)
7. [Контакты](#контакты)

---
## **Архитектура**

### C4-модель

![C4_1](./media/C4_1.png)

Представленная диаграмма является самым высокоуровневым представлением архитектуры и определяет место проектируемого программного средства в его экосистеме. Диаграмма наглядно демонстрирует границы системы, ее основных пользователей и ключевые зависимости от внешних программных систем.

Центральным элементом диаграммы является разрабатываемое программное средство – «Интернет-магазин». Это веб-приложение, спроектированное для того, чтобы предоставить покупателям инновационный способ поиска книг, а менеджерам – удобные инструменты для управления магазином.

С программным средством взаимодействуют два типа пользователей. Основным является покупатель, который использует публичный веб-интерфейс, чтобы искать книги и оформлять заказы. Для внутренних бизнес-процессов предусмотрена роль менеджера – сотрудника компании, который через административную панель управляет каталогом книг и заказами, а также имеет возможность просмотра статистики.

Для реализации своей ключевой функциональности программное средство тесно интегрировано с рядом внешних сервисов. Для обеспечения интеллектуального поиска и работы ИИ-ассистента, программное средство обращается к внешнему провайдеру языковых моделей – OpenAI API, чтобы генерировать ответы и обрабатывать запросы на естественном языке. Процесс наполнения каталога автоматизирован за счет взаимодействия с Google Books API, откуда система импортирует подробную информацию о книгах. Для коммуникации с пользователями, например, для отправки подтверждения о создании заказа, система использует внешний почтовый сервер (Mail Server), который отправляет email-уведомления и доставляет их в почтовый ящик покупателя.

![C4_2](./media/C4_2.png)

Данная диаграмма детализирует внутреннюю структуру программного средства, раскрывая его высокоуровневую архитектуру. Она показывает основные исполняемые единицы и хранилища данных (контейнеры), из которых состоит программное средство, их технологический стек и принципы взаимо-действия.

Архитектура программного средства основана на разделении клиентской и серверной частей. Пользователи, как покупатель, так и менеджер, взаимодействуют с программным средством через SPA (Single-Page Application) – клиентское приложение, работающее в их веб-браузере. Этот контейнер, разработанный с использованием React, отвечает за весь пользовательский интерфейс и отправляет REST API запросы на сервер.

Все запросы от SPA обрабатываются центральным контейнером – Backend API. Это серверное приложение, написанное на Java с использованием фреймворка Spring Boot, является «мозгом» всего программного средства. Оно реализует всю бизнес-логику, управляет данными и координирует взаимодействие с другими контейнерами и внешними системами.

Для хранения данных используются два специализированных контейнера. Primary Database, реализованная на базе MySQL, выступает в роли основного хранилища и «источником правды». Она хранит всю структурированную информацию о пользователях, книгах, заказах и отзывах. Backend API выполняет транзакционные операции с этой базой данных с использованием технологии JDBC. В свою очередь, для реализации продвинутых поисковых возможностей используется отдельный контейнер – Search Engine, реализованный на базе Elasticsearch. Он хранит денормализованные данные о книгах, оптимизированные для быстрого поиска как по ключевым словам, так и по векторам для семантического поиска. Backend API при обращении к данному контейнеру отвечает за выполнение поисковые запросов.

Backend API также является точкой интеграции с внешними системами. Для обеспечения работы ИИ-ассистента он обращается к OpenAI API, для наполнения каталога – к Google Books API, откуда импортирует подробную информацию о книгах, а для отправки уведомлений – к внешнему Mail Server (по протоколу SMTP).

![C4_3](./media/C4_3.png)

Данная диаграмма детализирует внутреннюю архитектуру ключевого контейнера системы – Backend API. Она раскрывает его внутреннюю структуру, показывая основные логические компоненты, их обязанности и технологическую реализацию, а также то, как они взаимодействуют для выполнения бизнес-задач.

Взаимодействие с внешним миром начинается с компонента REST API Controllers. Этот компонент, реализованный на базе Spring MVC, служит точкой входа для всех запросов от клиентского приложения SPA. Его основная задача – принимать HTTP-запросы, проводить их первичную валидацию и передавать запросы на выполнение соответствующим компонентам прикладного уровня.

Для реализации пользовательских сценариев, не связанных с ИИ, используется компонент Application Services. Этот тонкий слой координирует выполнение бизнес-операций. Он выполняет бизнес-логику, обращаясь к компоненту Domain Model, где инкапсулированы все бизнес-правила согласно принципам Domain-Driven Design (DDD). Для сохранения и извлечения данных агрегатов Application Services сохраняют и извлекают данные, используя компонент Repositories (JPA), который абстрагирует работу с Primary Database (MySQL).

Вся логика, связанная с ИИ-ассистентом, инкапсулирована в компоненте AI Assistant Facade. Он получает запросы от контроллеров и, в зависимости от их характера, использует либо семантический поиск, либо «агентный» подход. Для семантического поиска AI Assistant Facade выполняет семантический поиск, обращаясь к компоненту Search Client. Search Client, в свою очередь, получает ответы на поисковые запросы, взаимодействуя с контейнером Search Engine. Для обогащения ответа AI Assistant Facade получает детали о найденных книгах, используя Repositories (JPA).

Для ответов на структурированные, фактические запросы (например, «какая книга самая популярная?» или «какие отзывы у книги...») AI Assistant Facade использует «агентный» подход. В этом сценарии ИИ-ассистент выступает в роли «диспетчера»: он анализирует запрос пользователя и определяет, какой из методов-инструментов, предоставленных компонентом BooksTool, необходимо вызвать для получения ответа. BooksTool, в свою очередь, выполняет конкретную бизнес-операцию, взаимодействуя с Repositories (JPA) для получения точных данных из Primary Database. Полученный от инструмента результат затем используется ИИ-ассистентом для формирования финального, осмысленного ответа пользователю.

Взаимодействие со всеми внешними системами изолировано в отдельных компонентах. External API Clients, реализованные на базе Spring WebClient, выполняют API-вызовы к OpenAI API и Google Books API, чтобы получать векторы и генерировать ответы или импортировать информацию о книгах. Компонент Email Service отвечает за отправку уведомлений: Application Services отправляют email-уведомления, используя этот сервис, который, в свою очередь, взаимодействует с внешним Mail Server.

Такая компонентная структура четко разделяет обязанности, изолирует бизнес-логику от инфраструктурных деталей и обеспечивает высокую модульность и тестируемость программного средства.

![C4_4](./media/C4_4.png)

Данная диаграмма представляет собой детализацию компонентного уровня и раскрывает внутреннюю структуру ключевого компонента AI Assistant Facade. Она соответствует упрощенной диаграмме классов в нотации UML и предназначена для разъяснения, как именно реализована сложная логика ИИ-ассистента на уровне кода, какие классы и интерфейсы задействованы и как они взаимодействуют.

Был выбран именно компонент AI Assistant Facade, поскольку он является ядром инновационной функциональности программного средства и обладает наибольшей архитектурной сложностью. В отличие от других компонентов, его реализация нетривиальна и включает в себя организацию множества взаимодействий между различными частями системы для реализации ключевой функциональности. Диаграмма кодового уровня для этого компонента имеет наивысшую ценность, так как она визуализирует неочевидную внутреннюю логику, демонстрируя, как именно сосуществуют и координируются механизмы Retrieval-Augmented Generation (RAG) для семантического поиска и механизм вызова сервисных функций для структурированных запросов. Таким образом, детализация AI Assistant Facade превращает «черный ящик» ИИ-логики в понятную схему, что критически важно для понимания самой сложной и уникальной части программного средства.

Центральным элементом является класс AiAssistantFacade, который служит точкой входа и делегирует выполнение задач двум разным механизмам в зависимости от типа запроса пользователя.

Первый механизм представлен интерфейсом Assistant, который отвечает за обработку структурированных запросов путем вызова предопределенных функций. Его реализация, создаваемая с помощью библиотеки Langchain4j, использует класс BooksTool, предоставляющий набор конкретных методов-инструментов для получения фактической информации из базы данных.

Второй механизм – ConversationalRetrievalChain – это класс, реализующий подход Retrieval-Augmented Generation (RAG) для семантического поиска по описательным запросам. Для своей работы он зависит от интерфейса ContentRetriever, который отвечает за извлечение релевантного контекста.

Создание и конфигурация этих сложных объектов инкапсулированы в классе AiConfig. Этот класс действует как «фабрика», которая собирает все необходимые зависимости для построения Assistant и ConversationalRetrievalChain. Он зависит от набора ключевых интерфейсов-абстракций Langchain4j:
- ChatLanguageModel: контракт для взаимодействия с чат-моделью;
- EmbeddingModel: контракт для преобразования текста в векторы;
- EmbeddingStore: контракт для взаимодействия с векторным хранилищем.

Эти интерфейсы являются «портами», реализации которых предоставляются другими компонентами системы (External API Clients и Search Client), что позволяет компоненту AI Assistant Facade оставаться независимым от конкретных внешних технологий. Также для управления диалогами AiAssistantFacade использует интерфейс ChatMemoryProvider.

Таким образом, кодовый уровень диаграммы наглядно демонстрирует, как с помощью принципа инверсии зависимостей и четкого разделения обязанностей между классами реализуется сложная, но модульная и расширяемая архитектура ИИ-ассистента.

### Схема данных

Ниже представлена физическая схема спроектированной базы данных.
![db.jpg](media/db.jpg)

---

## **Функциональные возможности**

### Диаграмма вариантов использования

Диаграмма вариантов использования и ее описание

### User-flow диаграммы

Ниже представлена user-flow диаграмма для клиента.
![img.png](media/client_user-flow.png)

Для детального анализа пользовательского взаимодействия для роли клиента была построена user-flow диаграмма, иллюстрирующая путь покупателя от поиска подходящей книги до успешного оформления заказа. Был вы-бран именно этот сценарий, поскольку он является ключевым бизнес-процессом всего программного средства. Эта диаграмма наглядно демонстрирует все шаги, которые проходит клиент для достижения своей основной цели. Анализ этого пути позволит выявить потенциальные «узкие места» и спроектировать максимально оптимальный и бесшовный пользовательский опыт.

Данный пользовательский путь начинается на главной странице каталога, где клиент принимает первое решению: знает ли он, что ищет, или ему нужна помощь в выборе. Если клиент ищет что-то конкретное, он вводит запрос в поисковую строку. В случае, если результаты найдены, он переходит к их изучению. Если же поиск не дал результатов или оказался неточным, клиент может применить фильтры и сортировку, чтобы уточнить выборку. В качестве альтернативы, если клиент не уверен в своем выборе, он может обратиться к ИИ-ассистенту, задав ему вопрос в свободной форме и получив в ответ персонализированную рекомендацию.

После того как подходящая книга найдена в результатах поиска, клиент кликает на ее карточку и переходит на страницу детального просмотра, где изучает всю необходимую информацию. На этом этапе он может добавить книгу в корзину, после чего ему придет уведомление об ее успешном добавлении, и он сможет либо продолжить покупки, либо перейти в корзину. В боковой панели корзины клиент проверяет состав заказа и инициирует переход к финальному этапу – оформлению заказа.

Именно на этом этапе происходит ветвление, связанное с аутентификацией – происходит проверка на авторизацию клиента. Если он не авторизован, ему предлагается выбор: пройти быструю регистрацию или войти в существующий аккаунт. После успешной аутентификации клиент попадает на страницу оформления заказа. Здесь ему снова предлагается выбор: использовать один из сохраненных адресов или, если его нет, ввести новые реквизиты для доставки. После заполнения всех необходимых данных и выбора времени доставки клиент видит финальное подтверждение и завершает процесс. Путь заканчивается получением уведомления об успешном оформлении заказа, что является конечной точкой данного пользовательского сценария.

Ниже представлена user-flow диаграмма для менеджера.
![img.png](media/manager_user-flow.png)

Для детального анализа пользовательского взаимодействия для роли менеджера была построена user-flow диаграмма, иллюстрирующая путь менеджера при добавлении новой книги в каталог, как наиболее сложный и функционально насыщенный сценарий. Эта диаграмма наглядно демонстрирует, как менеджер взаимодействует с программным средством для выполнения своей ключевой задачи и показывает все основные ветвления и шаги, в том числе и использование интеграции с внешним сервисом.

Данный пользовательский путь начинается с авторизации, после чего менеджер попадает на главную страницу каталога. Здесь он инициирует процесс, переходя к добавлению новой книги, при этом на данном этапе ему предлагается выбор способа добавления книги – через API или с нуля.

При выборе способа добавления через API, менеджер попадает в диалоговое окно поиска, где вводит ISBN или название искомой книги, после чего выполняется поиск, и в зависимости от его результата поток разветвляется: если соответствующие книги найдены, менеджер видит их список, выбирает один из результатов, и переходит на форму редактирования с импортированными данными; если же книги не найдены, показывается соответствующее уведомление, и менеджеру предлагается повторить поиск или перейти к ручному добавлению с нуля.

При выборе пути способа добавления с нуля или после неудачного поиска через API, менеджер попадает на пустую форму редактирования книги, где он заполняет все необходимые поля вручную. В случае с импортированными данными, менеджер проверяет их (при необходимости изменяя) и заполняет недостающие внутренние поля, такие как цена и количество. Оба пути сходятся на общем шаге – загрузке изображений (превью, обложки и страниц предпросмотра). После того как все данные готовы, менеджер сохраняет книгу.

Процесс завершается тем, что менеджеру показывается уведомление об успешном добавлении новой книги и он перенаправляется обратно на главную страницу каталога, где он может видеть только что добавленную книгу в общем списке, что является логической конечной точкой данного сценария.

---

## **Детали реализации**

### UML-диаграммы

Представить все UML-диаграммы , которые позволят более точно понять структуру и детали реализации ПС

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

Описать подходы, использованные для обеспечения безопасности, включая описание процессов аутентификации и авторизации с примерами кода из репозитория сервера

### Оценка качества кода

Используя показатели качества и метрики кода, оценить его качество

---

## **Тестирование**

### Unit-тесты

Представить код тестов для пяти методов и его пояснение

### Интеграционные тесты

Представить код тестов и его пояснение

---

## **Установка и запуск**

### Манифесты для сборки docker образов

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

### Манифесты для развертывания k8s кластера

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [LICENSE.md](./LICENSE.md)

---

## **Контакты**

Коршов Матвей Игоревич: korsovm@gmail.com
